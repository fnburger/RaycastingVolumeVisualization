#ifndef GL_ES
#version 330 es
#endif

#define PI 3.1415926535

precision highp int;
precision highp float;
precision highp sampler3D;

//uniform vec3 color[2];
//uniform int colorIdx;

uniform vec3 boundBox;
uniform sampler3D volume;
uniform vec2 resolution;

in vec3 rayDir;
in vec3 transformedEye;

out vec4 fragColor;

// returns the hit with the boundBox
vec2 intersectBox(vec3 r0, vec3 dir) {
    vec3 boxMin = vec3(-boundBox.x/2.0, -boundBox.y/2.0, boundBox.z/2.0);
    vec3 boxMax = vec3(boundBox.x/2.0, boundBox.y/2.0, -boundBox.z/2.0);
    vec3 invDir = 1.0 / dir;
    vec3 tmin_tmp = (boxMin - r0) * invDir;
    vec3 tmax_tmp = (boxMax - r0) * invDir;
    vec3 tmin = min(tmin_tmp, tmax_tmp);
    vec3 tmax = max(tmin_tmp, tmax_tmp);
    float t0 = max(tmin.x, max(tmin.y, tmin.z));
    float t1 = min(tmax.x, min(tmax.y, tmax.z));
    return vec2(t0, t1);
}

// returns the color value of the volume 3D texture at the given position
vec3 sampleVolumeColor(vec3 position) {
    return texture(volume, position).rgb;
}

// returns the alpha value of the volume 3D texture at the given position
float sampleVolumeOpacity(vec3 position) {
  return texture(volume, position).a;
}

void main() {

    // Idee 2: normalisierte Variante
    // Get the coordinates of the current pixel
    //vec2 uv = ((gl_FragCoord.xy * 2.0) - resolution.xy) / resolution.y;
    // Calculate the direction of the ray from the camera position to the current pixel
    //vec3 rayDirectionNorm = normalize(vec3(uv - rayOriginNorm.xy, -rayOriginNorm.z));

    // ############# sampling the volume ##############
    // Intersect ray with volume using slab method
    vec3 rayDirection = normalize(rayDir);
    vec3 rayOrigin = transformedEye;

    vec2 t_hit = intersectBox(rayOrigin, rayDirection);
    if(t_hit.x > t_hit.y){
      discard; // No hit
    }
    // ignore voxels behind the camera
    t_hit.x = max(t_hit.x, 0.0);
    
    // define step size for marching through volume
    vec3 dt_vec = 1.0 / (vec3(boundBox) * abs(rayDirection));
    float dt = min(dt_vec.x, min(dt_vec.y, dt_vec.z));

    // initialise voxel color as black
    vec4 voxelColor = vec4(0.0);

    vec3 boundingBoxMin = vec3(-boundBox.x, boundBox.y, boundBox.z);
    vec3 boundingBoxMax = vec3(boundBox.x, -boundBox.y, -boundBox.z);

    // Starting from the entry point, march the ray through the volume and sample it
    vec3 p = rayOrigin * 2.0 + (t_hit.x) * rayDirection;
    for (float t = t_hit.x; t < t_hit.y; t += dt) {
      // compute position in volume to sample
      vec3 samplePos = p + rayDirection * t;
      vec3 texCoord = (samplePos - boundingBoxMax) / ((boundingBoxMin - boundingBoxMax) * 1.0);
      // sample 3d texture 
      float val = texture(volume, texCoord).r; // changed p to texCoord
      // use sampled value as alpha
      vec4 val_color = vec4(vec3(1.0), val);
      // MIP - overwrite value if new value is bigger (higher intensity)
      if (voxelColor.a < val_color.a) {
        voxelColor = val_color;
      }

      // make next step along ray
      p += rayDirection * dt;
    }

    fragColor = voxelColor;
}

