#ifndef GL_ES
#version 330 es
#endif

precision highp int;
precision highp float;
precision highp sampler3D;

//uniform vec3 color[2];
//uniform int colorIdx;

uniform vec3 boundBox;
uniform sampler3D volume;
uniform vec2 resolution;
uniform float u_isoValue;
// transfer function uniforms
uniform int numIsosurfaces;
uniform float isoValues[3]; // maximum of 3 isosurfaces
uniform vec3 isoColors[3];
uniform float isoOpacities[3];

in vec3 rayDir;
in vec3 transformedEye;

out vec4 fragColor;

// returns the hit with the boundBox
vec2 intersectBox(vec3 r0, vec3 dir) {
    vec3 boxMin = vec3(-boundBox.x/2.0, -boundBox.y/2.0, -boundBox.z/2.0);
    vec3 boxMax = vec3(boundBox.x/2.0, boundBox.y/2.0, boundBox.z/2.0);
    vec3 invDir = 1.0 / dir;
    vec3 tmin_tmp = (boxMin - r0) * invDir;
    vec3 tmax_tmp = (boxMax - r0) * invDir;
    vec3 tmin = min(tmin_tmp, tmax_tmp);
    vec3 tmax = max(tmin_tmp, tmax_tmp);
    float t0 = max(tmin.x, max(tmin.y, tmin.z));
    float t1 = min(tmax.x, min(tmax.y, tmax.z));
    return vec2(t0, t1);
}

// returns the interpolated 3d position of the first intersection point of the ray and the volume
vec3 computeFirstHit(vec3 pos_current, vec3 pos_next, float value_current, float value_next) {
    float t = (u_isoValue - value_current) / (value_next - value_current);
    return pos_current + t * (pos_next - pos_current);
}

vec3 newInterpolation(vec3 pos_current, vec3 pos_prev, int i, float value_current, float value_prev) {
    return mix(pos_prev, pos_current, (isoValues[i] - value_prev) / (value_current - value_prev));
}

// returns the gradient of the surface at the first-hit position
vec3 computeGradient(sampler3D volume, vec3 texCoord) {
    // Calculate offset based on texture size
    ivec3 texSize = textureSize(volume, 0);
    vec3 offset = vec3(1.0 / float(texSize.x), 1.0 / float(texSize.y), 1.0 / float(texSize.z));

    // Sample the volume texture at offset positions
    float valueX1 = texture(volume, texCoord + vec3(offset.x, 0.0, 0.0)).r;
    float valueX2 = texture(volume, texCoord - vec3(offset.x, 0.0, 0.0)).r;
    float valueY1 = texture(volume, texCoord + vec3(0.0, offset.y, 0.0)).r;
    float valueY2 = texture(volume, texCoord - vec3(0.0, offset.y, 0.0)).r;
    float valueZ1 = texture(volume, texCoord + vec3(0.0, 0.0, offset.z)).r;
    float valueZ2 = texture(volume, texCoord - vec3(0.0, 0.0, offset.z)).r;

    // Compute the gradient
    vec3 gradient = vec3(valueX1 - valueX2, valueY1 - valueY2, valueZ1 - valueZ2);
    return gradient;
}


void main() {
    // ############# sampling the volume ##############

    // Intersect ray with volume using slab method
    vec3 rayDirection = normalize(rayDir);
    vec3 rayOrigin = transformedEye;

    vec2 t_hit = intersectBox(rayOrigin, rayDirection);
    if(t_hit.x > t_hit.y){
      discard; // No hit
    }
    // ignore voxels behind the camera
    t_hit.x = max(t_hit.x, 0.0);

    // define step size multiplier. Higher is less accurate but more performant.
    float dtMulti = 1.0;
    // define step size for marching through volume
    vec3 dt_vec = 1.0 / (vec3(boundBox) * abs(rayDirection));
    float dt = min(dt_vec.x, min(dt_vec.y, dt_vec.z)) * dtMulti;
    
    // define bounds
    vec3 boundingBoxMin = vec3(-boundBox.x, boundBox.y, boundBox.z);
    vec3 boundingBoxMax = vec3(boundBox.x, -boundBox.y, -boundBox.z);

    // ###### starting from the entry point, march the ray through the volume and sample it ######
    vec3 p = rayOrigin * 2.0 + (t_hit.x) * rayDirection; // initialize sampling position
    bool firstHitFound = false;
    vec3 firstHitPosition = vec3(0.0);
    vec3 firstHitColor = vec3(0.0);
    float firstHitOpacity = 0.0;

    for (float t = t_hit.x; t < t_hit.y; t += dt) {
      // compute position in volume to sample
      vec3 samplePos = p + rayDirection * t;
      vec3 texCoord = (samplePos - boundingBoxMax) / ((boundingBoxMin - boundingBoxMax) * 1.0);
      // sample 3d texture 
      float alpha = texture(volume, texCoord).r;
      /*
      float interpVal = 0.0001;
      float alpha1 = texture(volume, texCoord + vec3(interpVal)).r;
      float alpha2 = texture(volume, texCoord - vec3(interpVal)).r;
      float alpha3 = texture(volume, texCoord + vec3(-interpVal, interpVal, interpVal)).r;
      float alpha4 = texture(volume, texCoord + vec3(interpVal, -interpVal, interpVal)).r;
      float alpha5 = texture(volume, texCoord + vec3(interpVal, interpVal, -interpVal)).r;
      alpha = mix(alpha, alpha1, 0.5);
      alpha = mix(alpha, alpha2, 0.5);
      alpha = mix(alpha, alpha3, 0.5);
      alpha = mix(alpha, alpha4, 0.5);
      alpha = mix(alpha, alpha5, 0.5);
      */

      if (firstHitFound) {
            break; // this ray is done after its crossing of the ISO value was found
        }

        // first-hit compositing with transfer function: check for each voxel against multiple iso values
        for (int i = 0; i < numIsosurfaces; i++) {
            if (alpha >= isoValues[i]) {
                vec3 prevSamplePos = samplePos - rayDirection * dt;
                vec3 prevTexCoord = (prevSamplePos - boundingBoxMax) / ((boundingBoxMin - boundingBoxMax) * 1.0);
                float prevAlpha = texture(volume, prevTexCoord).r;

                if (prevAlpha < isoValues[i]) {
                    //firstHitPosition = computeFirstHit(prevSamplePos, samplePos, prevAlpha, alpha);
                    firstHitPosition = newInterpolation(samplePos, prevSamplePos, i, alpha, prevAlpha);
                    firstHitColor = isoColors[i];
                    firstHitOpacity = isoOpacities[i];
                    firstHitFound = true;
                    break;
                }
            }
        }

      // make next step along ray
      p += rayDirection * dt;
    }

    // ####### shading #######
    if (firstHitFound) {
        // use firstHitPosition for shading
        vec3 normalizedPosition = (firstHitPosition - boundingBoxMax) / (boundingBoxMin - boundingBoxMax);
        vec3 gradient = computeGradient(volume, normalizedPosition);
        vec3 normal = normalize(gradient);

        // Lighting calculations
        /*
        vec3 ambientColor = vec3(1.0, 1.0, 1.0); 
        vec3 lightColor = vec3(1.0, 1.0, 1.0); 
        vec3 lightDir = normalize(vec3(1.0, 1.0, 1.0)); 
        float diffuse = max(dot(normal, lightDir), 0.0); 
        vec3 viewDir = normalize(transformedEye - firstHitPosition); 
        vec3 reflectDir = reflect(-lightDir, normal); 
        float specular = pow(max(dot(viewDir, reflectDir), 0.0), 32.0);

        float textureValue = texture(volume, normalizedPosition).r;
        vec3 colorFromTexture = vec3(textureValue);

        vec3 ambient = ambientColor * colorFromTexture;
        vec3 diffuseColor = lightColor * diffuse * colorFromTexture;
        vec3 specularColor = lightColor * specular;
        vec3 finalColor = ambient + diffuseColor + specularColor; 
        fragColor = vec4(finalColor, firstHitOpacity) * vec4(firstHitColor, 1.0);
        */

        // simple lighting
        vec3 lightDir = normalize(vec3(1.0, 1.0, 1.0));
        vec3 reflectDir = reflect(-lightDir, normal);
        vec3 viewDir = normalize(transformedEye - firstHitPosition); 
        float specular = pow(max(dot(viewDir, reflectDir), 0.0), 32.0);
        float diffuse = max(dot(normal, lightDir), 0.0);
        vec3 color = vec3(diffuse) + vec3(specular);
        fragColor = vec4(color, firstHitOpacity) * vec4(firstHitColor, 1.0);
        
    } else {
        fragColor = vec4(0.0, 0.0, 0.0, 1.0);
    }
}

