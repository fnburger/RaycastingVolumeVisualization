#ifndef GL_ES
#version 330 es
#endif

precision highp int;
precision highp float;
precision highp sampler3D;

//uniform vec3 color[2];
//uniform int colorIdx;

uniform vec3 cameraPos;
uniform vec3 boundBox;
uniform sampler3D volume;
uniform vec2 resolution;

out vec4 fragColor;

// returns the inverse of the given vector
vec3 vec3Inverse(vec3 v) {
    return vec3(1.0 / v.x, 1.0 / v.y, 1.0 / v.z);
}

// returns true if the ray intersects the boundBox
bool intersectsBox(vec3 ray, vec3 rayOrigin, vec3 boundBox) {
    vec3 ray_inv = vec3Inverse(ray);
    vec3 boxMin = vec3(-boundBox.x/2.0, boundBox.y/2.0, -boundBox.z/2.0);
    vec3 boxMax = vec3(boundBox.x/2.0, -boundBox.y/2.0, boundBox.z/2.0);

    float tx1 = (boxMin.x - rayOrigin.x)*ray_inv.x;
    float tx2 = (boxMax.x - rayOrigin.x)*ray_inv.x;
    
    float tmin = min(tx1, tx2);
    float tmax = max(tx1, tx2);

    float ty1 = (boxMin.y - rayOrigin.y)*ray_inv.y;
    float ty2 = (boxMax.y - rayOrigin.y)*ray_inv.y;

    tmin = max(tmin, min(ty1, ty2));
    tmax = min(tmax, max(ty1, ty2));

    return tmax >= tmin;
}

void main() {

    // Idee 1: simple Vektordifferenz
    vec3 rayOrigin = cameraPos;
    vec3 rayDirection = gl_FragCoord.xyz - rayOrigin;

    // Idee 2: normalisierte Variante
    // Get the coordinates of the current pixel
    vec2 uv = gl_FragCoord.xy / resolution.xy;
    // Calculate the direction of the ray from the camera position to the current pixel
    vec3 rayDirectionNorm = normalize(vec3(uv - rayOrigin.xy, 1.0));

    
    // Slab method
    if(intersectsBox(rayDirectionNorm, rayOrigin, boundBox)){
      fragColor = vec4(rayDirectionNorm, 1.0);
    } else {
      fragColor = vec4(1.0, 1.0, 1.0, 1.0);
    }



    // Final fragment color
    //fragColor = vec4(rayDirectionNorm, 1.0);
}

