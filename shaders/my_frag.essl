#ifndef GL_ES
#version 330 es
#endif

precision highp int;
precision highp float;
precision highp sampler3D;

//uniform vec3 color[2];
//uniform int colorIdx;

uniform ivec3 boundBox;
uniform sampler3D volume;
uniform vec2 resolution;

in vec3 rayDirection;
in vec3 transformedEye;

out vec4 fragColor;

// returns the hit with the boundBox
vec2 intersectBox(vec3 r0, vec3 dir) {
    vec3 boxMin = vec3(-boundBox.x/2, -boundBox.y/2, boundBox.z/2);
    vec3 boxMax = vec3(boundBox.x/2, boundBox.y/2, -boundBox.z/2);
    vec3 invDir = 1.0 / dir;
    vec3 tmin_tmp = (boxMin - r0) * invDir;
    vec3 tmax_tmp = (boxMax - r0) * invDir;
    vec3 tmin = min(tmin_tmp, tmax_tmp);
    vec3 tmax = max(tmin_tmp, tmax_tmp);
    float t0 = max(tmin.x, max(tmin.y, tmin.z));
    float t1 = min(tmax.x, min(tmax.y, tmax.z));
    return vec2(t0, t1);
}

// returns the color value of the volume 3D texture at the given position
vec3 sampleVolumeColor(vec3 position) {
    return texture(volume, position).rgb;
}

// returns the alpha value of the volume 3D texture at the given position
float sampleVolumeOpacity(vec3 position) {
  return texture(volume, position).a;
}

void main() {

    // Idee 1: simple Vektordifferenz
    //vec3 rayOrigin = cameraPos;
    // direction of the ray is position of fragment - rayOrigin
    //vec3 rayDirection = gl_FragCoord.xyz - rayOrigin;
    // Final fragment color
    //fragColor = vec4(rayDirectionNorm, 1.0);


    // Idee 2: normalisierte Variante
    // normalize rayOrigin
    //vec3 rayOriginNorm = cameraPos;
    // Get the coordinates of the current pixel
    //vec2 uv = ((gl_FragCoord.xy * 2.0) - resolution.xy) / resolution.y;
    // Calculate the direction of the ray from the camera position to the current pixel
    //vec3 rayDirectionNorm = normalize(vec3(uv - rayOriginNorm.xy, -rayOriginNorm.z));

    vec3 rayDirectionNorm = normalize(rayDirection);

    
    
    // Slab method
    /*if(intersectsBox(rayDirectionNorm, rayOriginNorm, boundBox)){
      fragColor = vec4(rayDirectionNorm, 1.0);
    } else {
      fragColor = vec4(1.0, 1.0, 1.0, 1.0);
    }*/
    
    // TODO: idea for sampling the volume
    // Intersect ray with volume
    vec2 t_hit = intersectBox(transformedEye, rayDirectionNorm);
    if(t_hit.x > t_hit.y){
      discard; // No hit
    }
    // ignore voxels behing the camera
    t_hit.x = max(t_hit.x, 0.0);
    
    // define step size for marching through volume
    vec3 dt_vec = 1.0 / (vec3(boundBox) * abs(rayDirectionNorm));
    float dt = min(dt_vec.x, min(dt_vec.y, dt_vec.z));
    vec4 voxelColor = vec4(0.0);

    vec3 boundingBoxMin = vec3(-boundBox.x/2, -boundBox.y/2, boundBox.z/2);
    vec3 boundingBoxMax = vec3(boundBox.x/2, boundBox.y/2, -boundBox.z/2);

    // Starting from the entry point, march the ray through the volume and sample it
    vec3 p = transformedEye + (t_hit.x) * rayDirectionNorm;
    for (float t = t_hit.x; t < t_hit.y; t += dt) {

      // new idea
      vec3 samplePos = p + rayDirectionNorm * t;
      vec3 texCoord = (samplePos - boundingBoxMin) / (boundingBoxMax - boundingBoxMin);
      // end

      float val = texture(volume, texCoord).r; // changed p to texCoord
      vec4 val_color = vec4(vec3(1.0), val);
      // MIP
      if (voxelColor.a < val_color.a) {
        voxelColor = val_color;
      }
      p += rayDirectionNorm * dt;
    }

    fragColor = voxelColor;
    
}

