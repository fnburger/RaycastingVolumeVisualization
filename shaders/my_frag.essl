#ifndef GL_ES
#version 330 es
#endif

precision highp int;
precision highp float;
precision highp sampler3D;

uniform vec3 boundBox;
uniform sampler3D volume;
uniform vec2 resolution;
uniform float u_isoValue;
uniform vec3 camDir;

// transfer function uniforms
uniform int numIsosurfaces;
uniform float isoValues[3]; // maximum of 3 isosurfaces
uniform vec3 isoColors[3];
uniform float isoOpacities[3];
uniform float sampling_rate;
uniform bool ao;

in vec3 rayDir;
in vec3 transformedEye;

out vec4 fragColor;

// returns the hit with the boundBox
vec2 intersectBox(vec3 r0, vec3 dir) {
    vec3 boxMin = vec3(-boundBox.x/2.0, -boundBox.y/2.0, -boundBox.z/2.0);
    vec3 boxMax = vec3(boundBox.x/2.0, boundBox.y/2.0, boundBox.z/2.0);
    vec3 invDir = 1.0 / dir;
    vec3 tmin_tmp = (boxMin - r0) * invDir;
    vec3 tmax_tmp = (boxMax - r0) * invDir;
    vec3 tmin = min(tmin_tmp, tmax_tmp);
    vec3 tmax = max(tmin_tmp, tmax_tmp);
    float t0 = max(tmin.x, max(tmin.y, tmin.z));
    float t1 = min(tmax.x, min(tmax.y, tmax.z));
    return vec2(t0, t1);
}

// returns the interpolated 3d position of the first intersection point of the ray and the volume
vec3 newInterpolation(vec3 pos_current, vec3 pos_prev, int i, float value_current, float value_prev) {
    return mix(pos_prev, pos_current, (isoValues[i] - value_prev) / (value_current - value_prev));
}

// returns the gradient of the surface at the first-hit position
vec3 computeGradient(sampler3D volume, vec3 texCoord) {
    // Calculate offset based on texture size
    ivec3 texSize = textureSize(volume, 0);
    vec3 offset = vec3(1.0 / float(texSize.x), 1.0 / float(texSize.y), 1.0 / float(texSize.z));

    // Sample the volume texture at offset positions
    float valueX1 = texture(volume, texCoord + vec3(offset.x, 0.0, 0.0)).r;
    float valueX2 = texture(volume, texCoord - vec3(offset.x, 0.0, 0.0)).r;
    float valueY1 = texture(volume, texCoord + vec3(0.0, offset.y, 0.0)).r;
    float valueY2 = texture(volume, texCoord - vec3(0.0, offset.y, 0.0)).r;
    float valueZ1 = texture(volume, texCoord + vec3(0.0, 0.0, offset.z)).r;
    float valueZ2 = texture(volume, texCoord - vec3(0.0, 0.0, offset.z)).r;

    // Compute the gradient
    vec3 gradient = vec3(valueX1 - valueX2, valueY1 - valueY2, valueZ1 - valueZ2);
    return gradient;
}

// approximates ambient occlusion by sampling the density of the volume along the normal direction and using these samples to attenuate the diffuse lighting component
float computeAmbientOcclusion(sampler3D volume, vec3 pos, vec3 normal, vec3 boundingBoxMin, vec3 boundingBoxMax, float isoValue, int numSamples) {
    float occlusion = 0.0;
    float stepSize = 0.02;
    for (int i = 0; i < numSamples; i++) {
        vec3 samplePos = pos + normal * stepSize * float(i);
        vec3 sampleTexCoord = (samplePos - boundingBoxMin) / (boundingBoxMax - boundingBoxMin);
        float sampleValue = texture(volume, sampleTexCoord).r;
        if (sampleValue == isoValue)
            occlusion += sampleValue;
    }
    return 1.0 - occlusion;
}


void main() {
    // ############# sampling the volume ##############

    // Intersect ray with volume using slab method
    vec3 rayDirection = normalize(rayDir);
    vec3 rayOrigin = transformedEye;

    vec2 t_hit = intersectBox(rayOrigin, rayDirection);
    if(t_hit.x > t_hit.y){
      discard; // No hit
    }
    // ignore voxels behind the camera
    t_hit.x = max(t_hit.x, 0.0);

    // define step size multiplier. Higher is less accurate but more performant.
    float dtMulti = sampling_rate;
    // define step size for marching through volume
    vec3 camDirNorm = normalize(camDir);
    float difference = 1.0 / dot(camDirNorm, rayDirection) + sampling_rate;
    vec3 dt_vec = 1.0 / (vec3(boundBox) * abs(rayDirection));
    float dt = min(dt_vec.x, min(dt_vec.y, dt_vec.z)) * difference;
    
    // define bounds
    vec3 boundingBoxMin = vec3(-boundBox.x / 2.0, -boundBox.y / 2.0, -boundBox.z / 2.0);
    vec3 boundingBoxMax = vec3(boundBox.x / 2.0, boundBox.y / 2.0, boundBox.z / 2.0);

    // ###### starting from the entry point, march the ray through the volume and sample it ######
    bool firstHitFound = false;
    vec3 firstHitPosition = vec3(0.0);
    vec4 accumulatedColor = vec4(0.0);
    float accumulatedOpacity = 0.0;

    for (float t = t_hit.x; t < t_hit.y; t += dt) {
      // compute position in volume to sample
      vec3 samplePos = rayOrigin + rayDirection * t; // changed p to rayOrigin
      vec3 texCoord = (samplePos - boundingBoxMin) / ((boundingBoxMax - boundingBoxMin) * 1.0);
      float alpha = texture(volume, texCoord).r; // sample 3d texture 
     

      if (firstHitFound) {
            break; // this ray is done after its crossing of the ISO value was found
        }

        // first-hit compositing with transfer function: check for each voxel against multiple iso values
        for (int i = 0; i < numIsosurfaces; i++) {
            
            

            // dynamically adjust step-size (clamped)
            //vec3 baseLine = normalize(transformedEye - vec3(transformedEye.x, transformedEye.y, boundBox.z));
            //float difference = dot(rayDirection, baseLine); // is bigger if vectors are similar
            // make step size smaller if vectors are not similar
            //dt = 1 / difference * sampling_rate;

            //dt = abs(isoValues[i] - alpha) * sampling_rate; // bigger steps if further away
            //if(dt < 0.01) dt = 0.01;
            //if(dt > 0.5) dt = 0.5;

            // found surface?
            if (alpha >= isoValues[i]) {
                vec3 prevSamplePos = samplePos - rayDirection * dt;
                vec3 prevTexCoord = (prevSamplePos - boundingBoxMin) / ((boundingBoxMax - boundingBoxMin) * 1.0);
                float prevAlpha = texture(volume, prevTexCoord).r;

                if (prevAlpha < isoValues[i]) {
                    firstHitPosition = newInterpolation(samplePos, prevSamplePos, i, alpha, prevAlpha); // interpolate actual 3d pos between steps
                    vec3 normalizedPosition = (firstHitPosition - boundingBoxMin) / (boundingBoxMax - boundingBoxMin);
                    vec3 gradient = computeGradient(volume, normalizedPosition);
                    vec3 normal = normalize(gradient);
                    // use gradient as normal for shading
                    vec3 lightDir = normalize(vec3(-1.0, 1.0, 1.0));
                    vec3 lightDir1 = normalize(vec3(1.0, 1.0, 1.0));
                    vec3 reflectDir = reflect(-lightDir, normal);
                    vec3 viewDir = normalize(transformedEye - firstHitPosition); 
                    float specular = pow(max(dot(viewDir, reflectDir), 0.0), 32.0);
                    float diffuse = max(dot(normal, lightDir), 0.0);
                    diffuse = diffuse + max(dot(normal, lightDir1), 0.0); // second lightsource to reduce shadows

                    // Compute ambient occlusion
                    float ambientOcclusion = 1.0f;
                    if (ao)
                        ambientOcclusion = computeAmbientOcclusion(volume, firstHitPosition, normal, boundingBoxMin, boundingBoxMax, isoValues[i], 16);
                    vec3 color = isoColors[i] * diffuse * ambientOcclusion + vec3(specular);

                    // cumulative color and opacity so we can see all layers
                    float opacity = isoOpacities[i] * (1.0 - accumulatedOpacity);
                    accumulatedColor += vec4(color, opacity) * opacity;
                    accumulatedOpacity += opacity;

                    if (accumulatedOpacity >= 1.0) {
                        fragColor = accumulatedColor;
                        return; // we can return because we would not be able to see anything behind a frag with opacity = 1
                    }
                    break;
                }
            }
        }
    }
    fragColor = accumulatedColor;
}